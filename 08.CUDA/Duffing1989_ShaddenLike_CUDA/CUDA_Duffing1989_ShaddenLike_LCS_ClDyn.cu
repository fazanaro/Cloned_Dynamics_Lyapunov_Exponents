/* ***********************************************************************************************************************************
 *
 * Name				: CUDA_Duffing1989_ShaddenLike_LCS_ClDyn.cu
 * Author			: Filipe I. fazanaro
 * Copyright		: The code is released under the GPL v3 license.
 * Email			: filipe.fazanaro at gmail.com
 * Initial Version	: 30/Mar/2015
 * Last Update:		: 15/Sep/2015
 *
 * ***********************************************************************************************************************************
 * DESCRIPTION
 *
 * - Calculation of the Lyapunov global exponents - using the Cloned Dynamics approach - for the forced Duffing
 * oscillator dynamical system [1,2].
 *
 * - Obtain the Lagrangian Coherent Structures (LCS) [3].
 *
 * - Employs the fourth-order Runge-Kutta integrator.
 *
 * - Employs separated functions for the dynamical systems, RK4 integration.
 *
 * ***********************************************************************************************************************************
 * OBSERVATIONS
 *
 * - To be done:
 * 		 - Implement separated functions for the Gram-Schimidt Reorthonormalization.
 *
 * ***********************************************************************************************************************************
 * REFERENCES
 * [1] Parker and Chua (1989) Practical Numerical algorithms for Chaotic Systems. Springer-Verlag.
 *
 * [2] Guckenheimer, Holmes (2002) Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields.
 * Springer. 2nd edition.
 *
 * [3] http://mmae.iit.edu/shadden/LCS-tutorial/overview.html
 *
 * [4] Wolf, Swift, Swinney, Vastano (1985) Determining Lyapunov exponents from time series, Physica 16D, pp 285-317.
 * DOI:10.1016/0167-2789(85)90011-9
 *
 * [5] Soriano, Fazanaro, Suyama, JRO, Attux and Madrid (2012) A method for Lyapunov spectrum estimation using
 * cloned dynamics and its application toÂ the discontinuously-excited FitzHugh-Nagumo model. Nonlinear Dynamics,
 * vol 67, no 1, pp 413-424. DOI: 10.1007/s11071-011-9989-2.
 *
 * [6] https://www.google.com/search?q=error%3A+constant+value+is+not+known+CUDA&ie=UTF-8&sa=Search&channel=fe&client=browser-ubuntu&hl=en
 *
 * [7] http://stackoverflow.com/questions/9936376/how-to-defined-a-cuda-shared-memory-with-a-size-known-at-run-time
 *
 * [8] http://stackoverflow.com/questions/5531247/allocating-shared-memory/5531640#5531640
 *
 * [9] How to define square waves in C:
 * http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave
 *
 * [10] Most important characteristics of GPUs
 * http://developer.download.nvidia.com/compute/cuda/4_1/rel/toolkit/docs/online/group__CUDART__DEVICE_g5aa4f47938af8276f08074d09b7d520c.html
 *
 * [11] MEASURING TIME
 * http://ivanlife.wordpress.com/2011/05/09/time-cuda/
 * http://devblogs.nvidia.com/parallelforall/how-implement-performance-metrics-cuda-cc/
 *
 * [12] Pearson product-moment correlation coefficient
 * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
 *
 * [13] http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
 *
 * [14] http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
 *
 * ***********************************************************************************************************************************
 */


/* ******************************************************************************************************************************** */
// includes, system

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include <cuda.h>
#include <cuda_runtime.h>	// For the CUDA runtime routines (prefixed with "cuda_")
#include <cuda_runtime_api.h>


/* ******************************************************************************************************************************** */
/* DEFINITIONS ******************************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define pi 3.141592653589793238462643383


/* ******************************************************************************************************************************** */
/* IMPORTANT DEFINITIONS: DYNAMICAL SYSTEMS DIMENSIONS **************************************************************************** */
/* ******************************************************************************************************************************** */

#define dim 2

#define dim_total dim*(dim+1)


/* ******************************************************************************************************************************** */
/* CUDA IMPORTANT DEFINITIONS ***************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define BlockSize 	32
#define GridSize	1


/* ******************************************************************************************************************************** */
/* GLOBAL DEFINITIONS ************************************************************************************************************* */
/* ******************************************************************************************************************************** */

// -------------------------------------------------------------------------------------------------------------------------------- //
// FINAL TIME --------------------------------------------------------------------------------------------------------------------- //
// -------------------------------------------------------------------------------------------------------------------------------- //

#define t_final 10.0

/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 														CALCULATE GLOBAL INDEX														*/
/* ******************************************************************************************************************************** */
__device__ size_t calculateGlobalIndex()
{

	// Which block are we?
	size_t const globalBlockIndex = blockIdx.x + blockIdx.y * gridDim.x;

	// Which thread are we within the block?
	size_t const localThreadIdx = threadIdx.x + blockDim.x * threadIdx.y;

	// How big is each block?
	size_t const threadsPerBlock = blockDim.x*blockDim.y;

	// Which thread are we overall?
	return localThreadIdx + globalBlockIndex*threadsPerBlock;

}
/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 												RUNGE KUTTA FOURTH ORDER INTEGRATOR													*/
/* ******************************************************************************************************************************** */
__device__ void odeRK4( double(*odefun)(double *, double, double *, double *), double * dydt, double h, double t0, double * y_init, double * vParameters, int nIntegra )
{

	// ============================================================================================================================ //
	// INITIALIZATIONS ============================================================================================================= //
	// ============================================================================================================================ //

	double Y0[dim_total];

	double k1[dim_total];
	double k2[dim_total];
	double k3[dim_total];
	double k4[dim_total];

	double t = t0;

	// ============================================================================================================================ //
	// MAIN LOOP ================================================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int idx_Integra = 0; idx_Integra < nIntegra; idx_Integra++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k1 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		odefun( k1, t, y_init, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k1[jj] = h*k1[jj];

			// Debug
			//printf("k1[%d] = %.6f\n", jj, k1[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k2 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k1[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k2, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k2[jj] = h*k2[jj];

			// Debug
			//printf("k2[%d] = %.6f\n", jj, k2[jj]);

		}

		//printf("\n");



		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k3 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k2[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k3, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k3[jj] = h*k3[jj];

			// Debug
			//printf("k3[%d] = %.6f\n", jj, k3[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k4 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k3[jj];

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k4, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k4[jj] = h*k4[jj];

			// Debug
			//printf("k4[%d] = %.6f\n", jj, k4[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE INITIAL CONDITIONS FOR THE NEXT ITERATION ------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			y_init[jj] = y_init[jj] + (1/6.0)*( k1[jj] + 2.0*k2[jj] + 2.0*k3[jj] + k4[jj] );

			// Debug
			//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
			//printf("[%.6f]", y_init[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE TIME STEP --------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// Debug
		//printf("t = %.6f\n\n", t);

		t += h;

		// Debug
		//printf("t = %.6f\n\n", t);


	} // END MAIN LOOP
	// ============================================================================================================================ //


	// ============================================================================================================================ //
	// RETURN THE INTEGRAION RESULTS ============================================================================================== //
	// ============================================================================================================================ //

	//printf("\n");

	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{

		dydt[jj] = y_init[jj];

		// Debug
		//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
		//printf("[%.6f]", y_init[jj]);

	}

	//printf("\n");

	// ============================================================================================================================ //

}
/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 															ODEFUN																	*/
/* ******************************************************************************************************************************** */
__device__ double odefun_Duffing1989_ShaddenLike( double * dydt, double t0, double * y_init, double * vParameters )
{

	// ============================================================================================================================ //
	// PARAMETERS ================================================================================================================= //
	// ============================================================================================================================ //

	double epsilon = vParameters[0];
	double gamma   = vParameters[1];
	double omega   = vParameters[2];

	double tShadden = vParameters[3];


	// ============================================================================================================================ //
	// INITIAL CONDITIONS ========================================================================================================= //
	// ============================================================================================================================ //

	// DYNAMIC MODEL - FIDUCIAL

	double y10 = y_init[0];
	double y20 = y_init[1];


	// DYNAMIC MODEL - CLONES

	double y30 = y_init[2];
	double y40 = y_init[3];


	double y50 = y_init[4];
	double y60 = y_init[5];


	// ============================================================================================================================ //
	// DYNAMIC MODEL ============================================================================================================== //
	// ============================================================================================================================ //

	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - ORIGINAL (or FIDUCIAL) ----------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[0] = y20;
	dydt[1] = y10 - pow(y10,3) - epsilon*y20 + gamma*cos( omega*tShadden );


	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - CLONES --------------------------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[2] = y50;
	dydt[3] = y60;

	dydt[4] = y30 - pow(y30,3) - epsilon*y50 + gamma*cos( omega*tShadden );
	dydt[5] = y40 - pow(y40,3) - epsilon*y60 + gamma*cos( omega*tShadden );


	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //


}
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 															KERNEL																	*/
/* ******************************************************************************************************************************** */
__global__ void kernel_Duffing1989_ShaddenLike_LCS_ClDyn(
		double * outLyap1, double * outLyap2,
		double * X0,
		double * Y0,
		const unsigned int numElements)
{

	/* **************************************************************************************************************************** */
	/* WORK OUT WHICH THREAD WE ARE *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	size_t const globalThreadIdx = calculateGlobalIndex();

	// If we're off the end, return now
	if (globalThreadIdx >= numElements)
		return;


	/* **************************************************************************************************************************** */
	/* DYNAMICAL SYSTEM PARAMETERS ************************************************************************************************ */
	/* **************************************************************************************************************************** */

	double epsilon 	= 0.25;
	double gamma 	= 0.3;
	double omega 	= 1.0;


	/* **************************************************************************************************************************** */
	/* This time instant defines the state of the dynamical system when one applies the LCS identification. *********************** */
	/* See [3] for further details. *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	double tShadden = 0.0;


	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETER VECTOR *************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vParameters[] = { epsilon, gamma, omega, tShadden };


	/* **************************************************************************************************************************** */
	/* IMPORTANT INITIALIZATIONS ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	unsigned int aux_counter = 0;

	unsigned int idxIterations = 0;


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLONED DYNAMICAL SYSTEM PERTURBATION - SEE [5] ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	const double delta = 0.0001;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// ORIGINAL SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	double vX0 = X0[globalThreadIdx];
	double vY0 = Y0[globalThreadIdx];


	double y_init_orig[] = { vX0, vY0 };


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// PERTURBATION MATRIX -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	// IDENTITY MATRIX
	double mIdentity[dim][dim];

	for ( unsigned int idxRows = 0; idxRows < dim; idxRows++)
		for ( unsigned int idxCols = 0; idxCols < dim; idxCols++)
		{

			if ( idxCols == idxRows )
				mIdentity[idxRows][idxCols] = delta;

			else
				mIdentity[idxRows][idxCols] = 0.0;

			// Debug
			//printf( "mIdentity[%d][%d] = %.4f\n", idxRows, idxCols, mIdentity[idxRows][idxCols] );

		}


	// 2D array to 1D array transformation

	const int HEIGHT = dim;
	const int WIDTH  = dim;

	double y_init_perturb[HEIGHT * WIDTH];

	for ( unsigned int idxHEIGHT = 0; idxHEIGHT < HEIGHT; idxHEIGHT++)
	{

		for ( unsigned int idxWIDTH = 0; idxWIDTH < WIDTH; idxWIDTH++)
		{

			y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH]= mIdentity[idxHEIGHT][idxWIDTH] + y_init_orig[idxHEIGHT];

			// Debug
			//printf( "[y_init_perturb[%d] = %.4f]", (idxHEIGHT*WIDTH + idxWIDTH), y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH] );

		}

		//printf( "\n" );

	}

	//printf( "\n\n" );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// COMPLETE SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	//printf( "\n\n" );


	double y_init[dim_total];


	for( unsigned int ii = 0; ii < dim_total; ii++){
		if( ii < dim ){

			y_init[ii] = y_init_orig[aux_counter];

			aux_counter++;

		}else{

			if( ii == dim )
				aux_counter = 0;

			y_init[ii] = y_init_perturb[aux_counter];

			aux_counter++;

		}

		// ------------------------------------------------------------------ //
		// INITIAL CONDITIONS DEBUG
		// ------------------------------------------------------------------ //

		//printf("y_init[%d] = %.6f\n", ii, y_init[ii]);

		// ------------------------------------------------------------------ //

	}

	//printf("\n\n");


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// Initial time
	double t_init = 0.0;

	// Aux
	double t_aux = 0.0;

	// Final time
	//double t_final = 5000.0;


	// Gram-Schimidt reorthonormalization time interval
	//   - See [5] for further details related to how to change this value.
	const double t_gsr = 0.5;


	// Time step
	const double h = 0.01;


	// Maximum iteration number
	const int nMaxItera = round( (double)(t_final - t_init) / t_gsr );
	//printf("\n nMaxItera per combination = %d\n", nMaxItera);

	// Defines how many iterations of the RK4 algorithm will be executed every iteration
	const int nIntegra = round( t_gsr / h );
	//printf("\n nIntegra per iteration = %d\n", nIntegra);

	// Defines the total number of iterations
	//const int n = nMaxItera*nIntegra;
	//printf("\n Total number of iterations per combination = %d\n", n);


	//printf("\n\n");


	/* **************************************************************************************************************************** */
	/* LYAPUNOV EXPONENTS INITIALIZATIONS ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	double LyapSoma[dim];
	//double Lyap[dim];

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// ARRAY INITIALIZAION -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	for( unsigned int ii = 0; ii < dim; ii++ )
	{

		LyapSoma[ii] = 0.0;
		//Lyap[ii] = 0.0;

	}


	/* **************************************************************************************************************************** */
	/* GRAM-SCHIMIDT REORTHONORMALIZATION ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vk[dim][dim];
	double uk[dim][dim];

	double deltax[dim][dim];


	for( unsigned int ii = 0; ii < dim; ii++ )
	{
		for( unsigned int jj = 0; jj < dim; jj++ )
		{
			vk[ii][jj] = 0.0;
			uk[ii][jj] = 0.0;

			deltax[ii][jj] = 0.0;
		}
	}


	/* **************************************************************************************************************************** */
	/* DYNAMICAL SYSTEM INTEGRATION *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	while (idxIterations < nMaxItera) {

		/* ======================================================================================================================== */
		/* DYNAMICAL SYSTEM INTEGRATION =========================================================================================== */
		/* ======================================================================================================================== */

		double dydt[dim_total];


		odeRK4( odefun_Duffing1989_ShaddenLike, dydt, h, t_init, y_init, vParameters, nIntegra );


		/* ======================================================================================================================== */
		/* AUXILIAR TIME "STEP" ATUALIZATION ====================================================================================== */
		/* ======================================================================================================================== */

		t_aux = t_aux + t_gsr;


		/* ======================================================================================================================== */
		/* DIFERENCE STATE VECTORS ================================================================================================ */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		deltax[0][0] = dydt[0] - dydt[3];
		//		deltax[0][1] = dydt[0] - dydt[4];
		//		deltax[0][2] = dydt[0] - dydt[5];
		//
		//		deltax[1][0] = dydt[1] - dydt[6];
		//		deltax[1][1] = dydt[1] - dydt[7];
		//		deltax[1][2] = dydt[1] - dydt[8];
		//
		//		deltax[2][0] = dydt[2] - dydt[9];
		//		deltax[2][1] = dydt[2] - dydt[10];
		//		deltax[2][2] = dydt[2] - dydt[11];


		// ------------------------------------------------------------------------------------------------------------------------ //
		// TRYING A BETTER WAY ---------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int idxRows = 0; idxRows < dim; idxRows++ )
		{
			for( unsigned int idxCols = 0; idxCols < dim; idxCols++ )
			{
				deltax[idxRows][idxCols] = dydt[idxRows] - dydt[dim*(idxRows+1)+idxCols];
			}
		}


		// ------------------------------------------------------------------------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj < dim; jj++ )
		//			{
		//				//printf( "[deltax[%d][%d] = %.6f]", ii, jj, deltax[ii][jj] );
		//				printf( "[%.12f]", deltax[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* GRAM-SCHIMIDT REORTHONORMALIZATION ===================================================================================== */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		double pdi1 = 0.0;


		double Norm1 = 0.0;
		double Norm2 = 0.0;


		// EXPONENT Lyap1
		vk[0][0] = deltax[0][0];
		vk[1][0] = deltax[1][0];

		Norm1 = sqrt( pow(vk[0][0],2)+pow(vk[1][0],2) );

		uk[0][0] = vk[0][0]/Norm1;
		uk[1][0] = vk[1][0]/Norm1;


		// EXPONENT Lyap2
		// 	- Remember: the numerator represents a dot product
		//	- Remember: the denumerator represents the square of each element of the vector
		pdi1 = ( uk[0][0]*deltax[0][1]+uk[1][0]*deltax[1][1] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0] );

		vk[0][1] = deltax[0][1] - pdi1 * uk[0][0];
		vk[1][1] = deltax[1][1] - pdi1 * uk[1][0];


		Norm2 = sqrt( pow(vk[0][1],2)+pow(vk[1][1],2) );

		uk[0][1] = vk[0][1]/Norm2;
		uk[1][1] = vk[1][1]/Norm2;


		// ------------------------------------------------------------------------------------------------------------------------ //
		// DEBUG - SCREEN - vk ---------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| vk[%d][%d] = %.12f |", ii, jj, vk[ii][jj] );
		//				printf( "[%.12f]", vk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN - uk ------------------------------------------------------------------------------------------------------------ //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| uk[%d][%d] = %.12f |", ii, jj, uk[ii][jj] );
		//				printf( "[%.12f]", uk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* LYAPUNOV EXPONENTS CALCULATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// LYAPUNOV EXPONENTS SUMMATION ------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		LyapSoma[0] = LyapSoma[0] + log( Norm1 / delta );
		LyapSoma[1] = LyapSoma[1] + log( Norm2 / delta );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj <= (idxIterations+1); jj++ )
		//			{
		//				//printf( "| LyapSoma[%d][%d] = %.8f | ", ii, jj, LyapSoma[ii][jj] );
		//				printf( "[%.12f]", LyapSoma[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* PREPARE FOR THE NEXT ITERATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// INITIAL CONDITIONS - THE DUMMY WAY ------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// ORIGINAL SYSTEM
		y_init[0] = dydt[0];
		y_init[1] = dydt[1];

		// CLONES
		y_init[2] = dydt[0] + delta*uk[0][0];
		y_init[3] = dydt[0] + delta*uk[0][1];

		y_init[4] = dydt[1] + delta*uk[1][0];
		y_init[5] = dydt[1] + delta*uk[1][1];

		// ------------------------------------------------------------------------------------------------------------------------ //

		idxIterations++;

		// ------------------------------------------------------------------------------------------------------------------------ //

		/* ======================================================================================================================== */

	} // END - ITERATIONS
	/* **************************************************************************************************************************** */


	/* **************************************************************************************************************************** */
	/* SYNC THREADS *************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	__syncthreads();



	/* **************************************************************************************************************************** */
	// KERNEL OUTPUT: GLOBAL LYAPUNOV EXPONENTS *********************************************************************************** */
	/* **************************************************************************************************************************** */

	outLyap1[globalThreadIdx] = LyapSoma[0] / (double)(t_final - t_init);
	outLyap2[globalThreadIdx] = LyapSoma[1] / (double)(t_final - t_init);

	/* **************************************************************************************************************************** */


} // END - KERNEL
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
/* 															MAIN FUNCTION															*/
/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
int main()
{

	/* **************************************************************************************************************************** */
	/* DEVICE INITIALIZATION ****************************************************************************************************** */
	/* **************************************************************************************************************************** */

	int numDevices = -1;	// number of devices
	int idxDevices = 0;

	cudaGetDeviceCount(&numDevices);

	if (numDevices == 0) {
		fprintf(stderr, "No CUDA devices found\n");
		return 1;
	}


	cudaError_t error = cudaSetDevice(idxDevices);

	if (error != cudaSuccess) {
		fprintf(stderr, "Error setting device to %d: %s\n", idxDevices, cudaGetErrorString(error));
		return 1;
	}


	/* **************************************************************************************************************************** */
	/* SOME INITIALIZATIONS ******************************************************************************************************* */
	/* **************************************************************************************************************************** */

	unsigned int aux_counter_Control_Param = 0;


	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETERS ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// VARIATION STEP OF THE CONTROL PARAMETERS ----------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double nIncControlParameter1 = 0.01;
	double nIncControlParameter2 = 0.01;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CONTROL PARAMETER VECTOR CONSTRUCTION -------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double vX0_min = -2.5;
	double vX0_max = 2.5;

	double vY0_min = -2.5;
	double vY0_max =2.5;


	int vX0_length = round( ((vX0_max - vX0_min)/nIncControlParameter1) + 1 );
	int vY0_length = round( ((vY0_max - vY0_min)/nIncControlParameter2) + 1 );


	double vX0[vX0_length];
	double vY0[vY0_length];



	for ( unsigned int ii = 0; ii < vX0_length; ii++ )
	{
		if (ii == 0)
			vX0[ii] = vX0_min;

		else
			vX0[ii] = vX0[ii-1] + nIncControlParameter1;

		// ------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------- //
		// ------------------------------------------------------ //

		//printf("vX0[%d] = %.4f\n", ii, vX0[ii]);

		// ------------------------------------------------------ //

	}

	//printf( "\n" );



	for( unsigned int ii = 0; ii < vY0_length; ii++ )
	{
		if ( ii == 0 )
			vY0[ii] = vY0_min;

		else
			vY0[ii] = vY0[ii-1] + nIncControlParameter2;

		// ------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------- //
		// ------------------------------------------------------ //

		//printf("vY0[%d] = %.4f\n", ii, vY0[ii]);

		// ------------------------------------------------------ //

	}

	//printf("\n");


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// HOW MANY COMBINATONS ------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	const int nNumCombinations = (vX0_length)*(vY0_length);

	// ---------------------------------------------------------------------------------------------------------------------------- //

	printf("\n Control parameters combinations = %.d\n", nNumCombinations );

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* POINTERS USED TO SAVA DATA ON DISK ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// TEMPORAL CHARACTERISTICS AND SOME OTHER THINGS ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Header = fopen("data_CUDA_Duffing1989_ShaddenLike_LCS_ClDyn_Header.dat", "w+");


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// LYAPUNOV EXPONENTS - Mz MATRIZ --------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Mz_Lyap = fopen("data_CUDA_Duffing1989_ShaddenLike_LCS_ClDyn_Mz_Lyap.dat", "w+");

	// ---------------------------------------------------------------------------------------------------------------------------- //

	if (fileData_Header == NULL)
	{
		printf(" Error opening the file 'data_CUDA_Duffing1989_ShaddenLike_LCS_ClDyn_Header.dat' !\n");
		exit(1);
	}


	if (fileData_Mz_Lyap == NULL)
	{
		printf(" Error opening the file 'data_CUDA_Duffing1989_ShaddenLike_LCS_ClDyn_Mz_Lyap.dat' !\n");
		exit(1);
	}

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* PUT SOME STRINGS AT THE BEGINNING OF THE DATA FILES ************************************************************************ */
	/* **************************************************************************************************************************** */

	fprintf( fileData_Mz_Lyap, "x0, y0, lambda1, lambda2\n" );



	/* **************************************************************************************************************************** */
	/* VARIABLES FOR CUDA EVENTS ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// INITIALIZE VARIABLES FOR THE CUDA EVENTS ----------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	float elapsedTimeKernel, elapsedTimeGather;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// INITIALIZE CUDA EVENTS ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEvent_t startKernel, stopKernel;
	cudaEvent_t startGather, stopGather;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CREATING EVENTS ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventCreate( &startKernel );
	cudaEventCreate( &stopKernel );

	cudaEventCreate( &startGather );
	cudaEventCreate( &stopGather );


	/* **************************************************************************************************************************** */
	/* POINTERS TO HOST MEMORY **************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double *Host_Lyap1, *Host_Lyap2;

	double *Host_vX0, *Host_vY0;


	/* **************************************************************************************************************************** */
	/* POINTERS TO DEVICE MEMORY ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double *Device_Lyap1, *Device_Lyap2;

	double *Device_vX0, *Device_vY0;


	/* **************************************************************************************************************************** */
	/* ALLOCATE ARRAYS ON HOST **************************************************************************************************** */
	/* **************************************************************************************************************************** */

	Host_Lyap1 = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_Lyap2 = (double *) malloc( (nNumCombinations)*sizeof(double) );

	Host_vX0 = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_vY0 = (double *) malloc( (nNumCombinations)*sizeof(double) );


	/* **************************************************************************************************************************** */
	/* ALLOCATE ARRAYS ON DEVICE ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	cudaError_t errDevLyap1 = cudaMalloc( (void **) &Device_Lyap1, (nNumCombinations)*sizeof(double) );
	cudaError_t errDevLyap2 = cudaMalloc( (void **) &Device_Lyap2, (nNumCombinations)*sizeof(double) );

	cudaError_t errDevX0 = cudaMalloc( (void **) &Device_vX0, (nNumCombinations)*sizeof(double) );
	cudaError_t errDevY0 = cudaMalloc( (void **) &Device_vY0, (nNumCombinations)*sizeof(double) );


	// IDENTIFY THE ERRORS
	if (errDevLyap1 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevLyap1), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevLyap2 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevLyap2), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevX0 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevX0), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevY0 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevY0), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	/* **************************************************************************************************************************** */
	/* INITIALIZE ARRAYS OF PARAMETERS ON HOST ************************************************************************************ */
	/* **************************************************************************************************************************** */

	for ( unsigned int idx_vX0 = 0; idx_vX0 < vX0_length; idx_vX0++ )
	{

		for ( unsigned int idx_vY0 = 0; idx_vY0 < vY0_length; idx_vY0++ )
		{

			// -------------------------------------------------------------------------------------------------------------------- //
			// CONTROL PARAMETERS ------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			Host_vX0[aux_counter_Control_Param] = vX0[idx_vX0];
			Host_vY0[aux_counter_Control_Param] = vY0[idx_vY0];


			// -------------------------------------------------------------------------------------------------------------------- //
			// PARAMETERS --------------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			/*Host_vX0[aux_counter_Control_Param] = epsilon;
			Host_vY0[aux_counter_Control_Param]   = gamma;
			Host_Omega[aux_counter_Control_Param]   = omega;*/


			// -------------------------------------------------------------------------------------------------------------------- //
			// AUX UPDATE --------------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			aux_counter_Control_Param++;

		}

	}


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// SCREEN - DEBUG ------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	//	printf( "\n" );
	//
	//	for ( unsigned int ii = 0; ii < nNumCombinations; ii++ )
	//		printf( " Host_vX0[%d] = %.4f  Host_vY0[%d] = %.4f \n", ii, Host_vX0[ii], ii, Host_vY0[ii] );



	/* **************************************************************************************************************************** */
	/* COPY DATA FROM HOST TO DEVICE MEMORY *************************************************************************************** */
	/* **************************************************************************************************************************** */

	cudaMemcpy( Device_vX0, Host_vX0, (nNumCombinations)*sizeof(double), cudaMemcpyHostToDevice );
	cudaMemcpy( Device_vY0, Host_vY0, (nNumCombinations)*sizeof(double), cudaMemcpyHostToDevice );


	/* **************************************************************************************************************************** */
	/* COMPUTE THE EXECUTION CONFIGURATION **************************************************************************************** */
	/* **************************************************************************************************************************** */

	//	dim3 dimBlock( BlockSize, 1, 1 );
	//	dim3 dimGrid ( (N/dimBlock.x) + (!(N%dimBlock.x)?0:1) );

	//dim3 dimBlock ( BlockSize, 1, 1 );
	//dim3 dimGrid  ( ceil( nNumCombinations/(double)BlockSize ), 1 );

	dim3 dimBlock ( BlockSize, BlockSize, 1 );
	dim3 dimGrid  ( ceil( nNumCombinations/(double)BlockSize ), ceil( nNumCombinations/(double)BlockSize ) );



	/* **************************************************************************************************************************** */
	/* EXECUTE THE KERNEL ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// START RECORDING ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord( startKernel, 0 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// EXECUTE THE MAIN KERNEL ---------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	kernel_Duffing1989_ShaddenLike_LCS_ClDyn<<<dimGrid,dimBlock>>>(
			Device_Lyap1, Device_Lyap2,
			Device_vX0,
			Device_vY0,
			nNumCombinations);


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// SYNCHRONIZE THREADS -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaThreadSynchronize();


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// FINISH RECORDING ----------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord( stopKernel, 0 );
	cudaEventSynchronize( stopKernel );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CALCULATE ELAPSED TIME ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaError_t errTimeKernel = cudaEventElapsedTime(&elapsedTimeKernel, startKernel, stopKernel);


	printf( "\n Time for the complete kernel execution [ms]: %.6f", elapsedTimeKernel );

	printf( "\n Time for the complete kernel execution [s] : %.6f \n\n", (elapsedTimeKernel / 1000.0) );


	if (errTimeKernel != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errTimeKernel), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	/* **************************************************************************************************************************** */
	/* COPY DATA FROM DEVICE MEMORY TO HOST MEMORY ******************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// START RECORDING ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord(startGather, 0);


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// COPY DATA ------------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaMemcpy( Host_Lyap1, Device_Lyap1, (nNumCombinations)*sizeof(double), cudaMemcpyDeviceToHost );
	cudaMemcpy( Host_Lyap2, Device_Lyap2, (nNumCombinations)*sizeof(double), cudaMemcpyDeviceToHost );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// FINISH RECORDING ----------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord(stopGather, 0);
	cudaEventSynchronize(stopGather);


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CALCULATE ELAPSED TIME ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaError_t errTimeGather = cudaEventElapsedTime(&elapsedTimeGather, startGather, stopGather);

	printf( " Time for copy data from device memory to host memory [ms]: %.6f \n", elapsedTimeGather);

	printf( " Time for copy data from device memory to host memory [s]:  %.6f \n", (elapsedTimeGather / 1000.0) );

	if (errTimeGather != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errTimeKernel), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}



	/* **************************************************************************************************************************** */
	/* PRINT/SAVE DATA ************************************************************************************************************ */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// LYAPUNOV EXPONENTS --------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	printf( "\n" );

	for ( unsigned int idx_storeLyap = 0; idx_storeLyap < nNumCombinations; idx_storeLyap++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//printf( " Host_vX0[%d] = %.4f  Host_vY0[%d] = %.4f  ", idx_storeLyap, Host_vX0[idx_storeLyap], idx_storeLyap, Host_vY0[idx_storeLyap] );

		//printf( " H_Lyap1[%d] = %.6f  ", idx_storeLyap, Host_Lyap1[idx_storeLyap] );

		//printf( " H_Lyap3[%d] = %.6f\n", idx_storeLyap, Host_Lyap2[idx_storeLyap] );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// DISK ------------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		fprintf( fileData_Mz_Lyap, "%.6f"  , Host_vX0[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.6f", Host_vY0[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.12f", Host_Lyap1[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.12f", Host_Lyap2[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, "\n" );

	}

	printf( "\n" );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLOSE FILES ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	fclose(fileData_Mz_Lyap);



	/* **************************************************************************************************************************** */
	/* DISK - TOTAL COMPUTATIONAL TIME AND SOME OTHERS PARAMETERS ***************************************************************** */
	/* **************************************************************************************************************************** */

	fprintf( fileData_Header, "Control parameters: vX0, vY0\n" );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "nIncControlParameter1 = %.6f\n", nIncControlParameter1 );
	fprintf( fileData_Header, "nIncControlParameter2 = %.6f\n", nIncControlParameter2 );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vX0_min = %.6f\n", vX0_min );
	fprintf( fileData_Header, "vX0_max = %.6f\n", vX0_max );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vY0_min = %.6f\n", vY0_min );
	fprintf( fileData_Header, "vY0_max = %.6f\n", vY0_max );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vX0_length = %d\n", vX0_length );
	fprintf( fileData_Header, "vY0_length = %d\n", vY0_length );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "t_final = %.6f\n", (double)t_final );
	fprintf( fileData_Header, "\n");

	fprintf( fileData_Header, "[block_size = %d] Time for the kernel [s]: %.12f \n", BlockSize, (elapsedTimeKernel / 1000.0) );
	fprintf( fileData_Header, "[block_size = %d] Time for the kernel [h]: %.12f \n\n", BlockSize, (elapsedTimeKernel / 1000.0) / 3600.0 );

	fprintf( fileData_Header, "[block_size = %d] Time for copy data from device memory to host memory [s]: %.12f \n", BlockSize, (elapsedTimeGather / 1000.0) );
	fprintf( fileData_Header, "[block_size = %d] Time for copy data from device memory to host memory [h]: %.12f \n\n", BlockSize, (elapsedTimeGather / 1000.0) / 3600.0 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLOSE FILES ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	fclose(fileData_Header);



	/* **************************************************************************************************************************** */
	/* IMPORTANT: FREE MEMORY ***************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// HOST MEMORY ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	free( Host_Lyap1 );
	free( Host_Lyap2 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// DEVICE MEMORY -------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaFree( Device_Lyap1 );
	cudaFree( Device_Lyap2 );

	cudaFree( Device_vX0 );
	cudaFree( Device_vY0 );


	/* **************************************************************************************************************************** */

	printf("\n That's all!!!\n\n");

	return 0;

	/* **************************************************************************************************************************** */

}
