/* ***********************************************************************************************************************************
 *
 * Name				: CUDA_Duffing1989_SpaceParam_ClDyn_epsilon_gamma.cu
 * Author			: Filipe I. fazanaro
 * Copyright		: The code is released under the GPL v3 license.
 * Email			: filipe.fazanaro at gmail.com
 * Initial Version	: 12/Feb/2015
 * Last Update:		: 12/Feb/2015
 *
 * ***********************************************************************************************************************************
 * DESCRIPTION
 *
 * - Calculation of the Lyapunov global exponents - using the Cloned Dynamics approach - for the forced Duffing
 * oscillator dynamical system [1,2].
 *
 * - Control parameters: 'epsilon' and 'gamma'.
 *
 * - Employs the fourth-order Runge-Kutta integrator.
 *
 * - Employs separated functions for the dynamical systems, RK4 integration.
 *
 * ***********************************************************************************************************************************
 * OBSERVATIONS
 *
 * - To be done:
 * 		 - Implement separated functions for the Gram-Schimidt Reorthonormalization.
 *
 * ***********************************************************************************************************************************
 * REFERENCES
 * [1] Parker and Chua (1989) Practical Numerical algorithms for Chaotic Systems. Springer-Verlag.
 *
 * [2] Guckenheimer, Holmes (2002) Nonlinear Oscillations, Dynamical Systems, and Bifurcations of Vector Fields.
 * Springer. 2nd edition.
 *
 * [3] http://mmae.iit.edu/shadden/LCS-tutorial/overview.html
 *
 * [4] Wolf, Swift, Swinney, Vastano (1985) Determining Lyapunov exponents from time series, Physica 16D, pp 285-317.
 * DOI:10.1016/0167-2789(85)90011-9
 *
 * [5] Soriano, Fazanaro, Suyama, JRO, Attux and Madrid (2012) A method for Lyapunov spectrum estimation using
 * cloned dynamics and its application toÂ the discontinuously-excited FitzHugh-Nagumo model. Nonlinear Dynamics,
 * vol 67, no 1, pp 413-424. DOI: 10.1007/s11071-011-9989-2.
 *
 * [6] https://www.google.com/search?q=error%3A+constant+value+is+not+known+CUDA&ie=UTF-8&sa=Search&channel=fe&client=browser-ubuntu&hl=en
 *
 * [7] http://stackoverflow.com/questions/9936376/how-to-defined-a-cuda-shared-memory-with-a-size-known-at-run-time
 *
 * [8] http://stackoverflow.com/questions/5531247/allocating-shared-memory/5531640#5531640
 *
 * [9] How to define square waves in C:
 * http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave
 *
 * [10] Most important characteristics of GPUs
 * http://developer.download.nvidia.com/compute/cuda/4_1/rel/toolkit/docs/online/group__CUDART__DEVICE_g5aa4f47938af8276f08074d09b7d520c.html
 *
 * [11] MEASURING TIME
 * http://ivanlife.wordpress.com/2011/05/09/time-cuda/
 * http://devblogs.nvidia.com/parallelforall/how-implement-performance-metrics-cuda-cc/
 *
 * [12] Pearson product-moment correlation coefficient
 * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
 *
 * [13] http://stackoverflow.com/questions/13677566/malloc-a-2d-array-in-c
 *
 * [14] http://stackoverflow.com/questions/1970698/using-malloc-for-allocation-of-multi-dimensional-arrays-with-different-row-lengt
 *
 * ***********************************************************************************************************************************
 */


/* ******************************************************************************************************************************** */
// includes, system

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include <cuda.h>
#include <cuda_runtime.h>	// For the CUDA runtime routines (prefixed with "cuda_")
#include <cuda_runtime_api.h>


/* ******************************************************************************************************************************** */
/* DEFINITIONS ******************************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define pi 3.141592653589793238462643383


/* ******************************************************************************************************************************** */
/* IMPORTANT DEFINITIONS: DYNAMICAL SYSTEMS DIMENSIONS **************************************************************************** */
/* ******************************************************************************************************************************** */

#define dim 3

#define dim_total dim*(dim+1)


/* ******************************************************************************************************************************** */
/* CUDA IMPORTANT DEFINITIONS ***************************************************************************************************** */
/* ******************************************************************************************************************************** */

#define BlockSize 	128
#define GridSize	2


/* ******************************************************************************************************************************** */
/* GLOBAL DEFINITIONS ************************************************************************************************************* */
/* ******************************************************************************************************************************** */

// -------------------------------------------------------------------------------------------------------------------------------- //
// CLONED DYNAMICAL SYSTEM PERTURBATION - SEE [5] --------------------------------------------------------------------------------- //
// -------------------------------------------------------------------------------------------------------------------------------- //

//#define delta 0.0001;


// -------------------------------------------------------------------------------------------------------------------------------- //
// FINAL TIME
// -------------------------------------------------------------------------------------------------------------------------------- //

#define t_final 10000.0


/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 														CALCULATE GLOBAL INDEX														*/
/* ******************************************************************************************************************************** */
__device__ size_t calculateGlobalIndex()
{

	// Which block are we?
	size_t const globalBlockIndex = blockIdx.x + blockIdx.y * gridDim.x;

	// Which thread are we within the block?
	size_t const localThreadIdx = threadIdx.x + blockDim.x * threadIdx.y;

	// How big is each block?
	//	- As entradas serao matrizes;
	size_t const threadsPerBlock = blockDim.x*blockDim.y;

	// Which thread are we overall?
	return localThreadIdx + globalBlockIndex*threadsPerBlock;

}
/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 												RUNGE KUTTA FOURTH ORDER INTEGRATOR													*/
/* ******************************************************************************************************************************** */
__device__ void odeRK4( double(*odefun)(double *, double, double *, double *), double * dydt, double h, double t0, double * y_init, double * vParameters, int nIntegra )
{

	// ============================================================================================================================ //
	// INITIALIZATIONS ============================================================================================================= //
	// ============================================================================================================================ //

	double Y0[dim_total];

	double k1[dim_total];
	double k2[dim_total];
	double k3[dim_total];
	double k4[dim_total];

	double t = t0;

	// ============================================================================================================================ //
	// MAIN LOOP ================================================================================================================== //
	// ============================================================================================================================ //
	for( unsigned int idx_Integra = 0; idx_Integra < nIntegra; idx_Integra++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k1 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		odefun( k1, t, y_init, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k1[jj] = h*k1[jj];

			// Debug
			//printf("k1[%d] = %.6f\n", jj, k1[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k2 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k1[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k2, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k2[jj] = h*k2[jj];

			// Debug
			//printf("k2[%d] = %.6f\n", jj, k2[jj]);

		}

		//printf("\n");



		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k3 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k2[jj]/2.0;

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k3, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k3[jj] = h*k3[jj];

			// Debug
			//printf("k3[%d] = %.6f\n", jj, k3[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// PARAMETER: k4 ---------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			Y0[jj] = y_init[jj] + k3[jj];

			// Debug
			//printf("Y0[%d] = %.6f\n", jj, Y0[jj]);

		}

		//printf("\n");


		odefun( k4, t, Y0, vParameters );

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			k4[jj] = h*k4[jj];

			// Debug
			//printf("k4[%d] = %.6f\n", jj, k4[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE INITIAL CONDITIONS FOR THE NEXT ITERATION ------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		for( unsigned int jj = 0; jj < dim_total; jj++ )
		{

			y_init[jj] = y_init[jj] + (1/6.0)*( k1[jj] + 2.0*k2[jj] + 2.0*k3[jj] + k4[jj] );

			// Debug
			//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
			//printf("[%.6f]", y_init[jj]);

		}

		//printf("\n");


		// ------------------------------------------------------------------------------------------------------------------------ //
		// UPDATE THE TIME STEP --------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// Debug
		//printf("t = %.6f\n\n", t);

		t += h;

		// Debug
		//printf("t = %.6f\n\n", t);


	} // END MAIN LOOP
	// ============================================================================================================================ //


	// ============================================================================================================================ //
	// RETURN THE INTEGRAION RESULTS ============================================================================================== //
	// ============================================================================================================================ //

	//printf("\n");

	for( unsigned int jj = 0; jj < dim_total; jj++ )
	{

		dydt[jj] = y_init[jj];

		// Debug
		//printf("y_init[%d] = %.6f\n", jj, y_init[jj]);
		//printf("[%.6f]", y_init[jj]);

	}

	//printf("\n");

	// ============================================================================================================================ //

}
/* ******************************************************************************************************************************** */




/* ******************************************************************************************************************************** */
/* 															ODEFUN																	*/
/* ******************************************************************************************************************************** */
__device__ double odefun_Duffing1989_ClDyn( double * dydt, double t0, double * y_init, double * vParameters )
{


	// ============================================================================================================================ //
	// PARAMETERS ================================================================================================================= //
	// ============================================================================================================================ //

	double epsilon = vParameters[0];
	double gamma   = vParameters[1];
	double omega   = vParameters[2];


	// ============================================================================================================================ //
	// INITIAL CONDITIONS ========================================================================================================= //
	// ============================================================================================================================ //

	// DYNAMIC MODEL - FIDUCIAL

	double y10 = y_init[0];
	double y20 = y_init[1];
	double y30 = y_init[2];


	// DYNAMIC MODEL - CLONES

	double y40 = y_init[3];
	double y50 = y_init[4];
	double y60 = y_init[5];

	double y70 = y_init[6];
	double y80 = y_init[7];
	double y90 = y_init[8];

	double y100 = y_init[9];
	double y110 = y_init[10];
	double y120 = y_init[11];


	// ============================================================================================================================ //
	// DYNAMIC MODEL ============================================================================================================== //
	// ============================================================================================================================ //

	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - ORIGINAL (or FIDUCIAL) ----------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[0] = y20;
	dydt[1] = y10 - pow(y10,3) - epsilon*y20 + gamma*cos( omega*y30 );
	dydt[2] = 1.0;


	// ----------------------------------------------------------------------- //
	// DYNAMICAL SYSTEM - CLONES --------------------------------------------- //
	// ----------------------------------------------------------------------- //

	dydt[3] = y70;
	dydt[4] = y80;
	dydt[5] = y90;

	dydt[6] = y40 - pow(y40,3) - epsilon*y70 + gamma*cos( omega*y100 );
	dydt[7] = y50 - pow(y50,3) - epsilon*y80 + gamma*cos( omega*y110 );
	dydt[8] = y60 - pow(y60,3) - epsilon*y90 + gamma*cos( omega*y120 );

	dydt[9]  = 1.0;
	dydt[10] = 1.0;
	dydt[11] = 1.0;

	// ============================================================================================================================ //

	return 0;

	// ============================================================================================================================ //


}
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* 															KERNEL																	*/
/* ******************************************************************************************************************************** */
__global__ void kernel_Duffing1989_SpaceParam_ClDyn_Epsilon_Gamma(
		double * outLyap1, double * outLyap2, double * outLyap3,
		double * Epsilon,
		double * Gamma,
		double * Omega,
		const unsigned int numElements)
{

	/* **************************************************************************************************************************** */
	/* WORK OUT WHICH THREAD WE ARE *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	size_t const globalThreadIdx = calculateGlobalIndex();

	// If we're off the end, return now
	if (globalThreadIdx >= numElements)
		return;


	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETERS ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	double epsilon 	= Epsilon[globalThreadIdx];
	double gamma 	= Gamma[globalThreadIdx];
	double omega 	= Omega[globalThreadIdx];


	//	printf( "thread = %d ", globalThreadIdx );
	//	printf( "epsilon = %.4f ", epsilon );
	//	printf( "gamma = %.4f ", gamma );
	//	printf( "omega = %.4f ", omega );

	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETER VECTOR *************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vParameters[] = { epsilon, gamma, omega };


	/* **************************************************************************************************************************** */
	/* IMPORTANT INITIALIZATIONS ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	unsigned int aux_counter = 0;

	unsigned int idxIterations = 0;


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLONED DYNAMICAL SYSTEM PERTURBATION - SEE [5] ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	const double delta = 0.0001;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// ORIGINAL SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	double vX0 = 1.0;
	double vY0 = 1.0;
	double vZ0 = 0.0;


	double y_init_orig[] = { vX0, vY0, vZ0 };


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// PERTURBATION MATRIX -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	// IDENTITY MATRIX
	double mIdentity[dim][dim];

	for ( unsigned int idxRows = 0; idxRows < dim; idxRows++)
		for ( unsigned int idxCols = 0; idxCols < dim; idxCols++)
		{

			if ( idxCols == idxRows )
				mIdentity[idxRows][idxCols] = delta;

			else
				mIdentity[idxRows][idxCols] = 0.0;

			// Debug
			//printf( "mIdentity[%d][%d] = %.4f\n", idxRows, idxCols, mIdentity[idxRows][idxCols] );

		}


	// 2D array to 1D array transformation

	const int HEIGHT = dim;
	const int WIDTH  = dim;

	double y_init_perturb[HEIGHT * WIDTH];

	for ( unsigned int idxHEIGHT = 0; idxHEIGHT < HEIGHT; idxHEIGHT++)
	{

		for ( unsigned int idxWIDTH = 0; idxWIDTH < WIDTH; idxWIDTH++)
		{

			y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH]= mIdentity[idxHEIGHT][idxWIDTH] + y_init_orig[idxHEIGHT];

			// Debug
			//printf( "[y_init_perturb[%d] = %.4f]", (idxHEIGHT*WIDTH + idxWIDTH), y_init_perturb[idxHEIGHT*WIDTH + idxWIDTH] );

		}

		//printf( "\n" );

	}

	//printf( "\n\n" );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// COMPLETE SYSTEM ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	//printf( "\n\n" );


	double y_init[dim_total];


	for( unsigned int ii = 0; ii < dim_total; ii++){
		if( ii < dim ){

			y_init[ii] = y_init_orig[aux_counter];

			aux_counter++;

		}else{

			if( ii == dim )
				aux_counter = 0;

			y_init[ii] = y_init_perturb[aux_counter];

			aux_counter++;

		}

		// ------------------------------------------------------------------ //
		// INITIAL CONDITIONS DEBUG
		// ------------------------------------------------------------------ //

		//printf("y_init[%d] = %.6f\n", ii, y_init[ii]);

		// ------------------------------------------------------------------ //

	}

	//printf("\n\n");


	/* **************************************************************************************************************************** */
	/* INITIAL CONDITIONS OF THE DYNAMICAL AND THE CLONED SYSTEMS ***************************************************************** */
	/* **************************************************************************************************************************** */

	// Initial time
	const double t_init = 0.0;

	// Aux
	double t_aux = 0.0;

	// Final time
	//const double t_final = 5000.0;


	// Gram-Schimidt reorthonormalization time interval
	//   - See [5] for further details related to how to change this value.
	const double t_gsr = 0.5;


	// Time step
	const double h = 0.01;


	// Maximum iteration number
	const int nMaxItera = round( (t_final - t_init) / t_gsr );
	//printf("\n nMaxItera per combination = %d\n", nMaxItera);

	// Defines how many iterations of the RK4 algorithm will be executed every iteration
	const int nIntegra = round( t_gsr / h );
	//printf("\n nIntegra per iteration = %d\n", nIntegra);

	// Defines the total number of iterations
	//const int n = nMaxItera*nIntegra;
	//printf("\n Total number of iterations per combination = %d\n", n);


	//printf("\n\n");


	/* **************************************************************************************************************************** */
	/* LYAPUNOV EXPONENTS INITIALIZATIONS ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	double LyapSoma[dim];
	//double Lyap[dim];

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// ARRAY INITIALIZAION -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	for( unsigned int ii = 0; ii < dim; ii++ )
	{

		LyapSoma[ii] = 0.0;
		//Lyap[ii] = 0.0;

	}


	/* **************************************************************************************************************************** */
	/* GRAM-SCHIMIDT REORTHONORMALIZATION ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	double vk[dim][dim];
	double uk[dim][dim];

	double deltax[dim][dim];


	for( unsigned int ii = 0; ii < dim; ii++ )
	{
		for( unsigned int jj = 0; jj < dim; jj++ )
		{
			vk[ii][jj] = 0.0;
			uk[ii][jj] = 0.0;

			deltax[ii][jj] = 0.0;
		}
	}


	/* **************************************************************************************************************************** */
	/* DYNAMICAL SYSTEM INTEGRATION *********************************************************************************************** */
	/* **************************************************************************************************************************** */

	while (idxIterations < nMaxItera) {

		/* ======================================================================================================================== */
		/* DYNAMICAL SYSTEM INTEGRATION =========================================================================================== */
		/* ======================================================================================================================== */

		double dydt[dim_total];


		odeRK4( odefun_Duffing1989_ClDyn, dydt, h, t_init, y_init, vParameters, nIntegra );


		/* ======================================================================================================================== */
		/* AUXILIAR TIME "STEP" ATUALIZATION ====================================================================================== */
		/* ======================================================================================================================== */

		t_aux = t_aux + t_gsr;


		/* ======================================================================================================================== */
		/* DIFERENCE STATE VECTORS ================================================================================================ */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		//		deltax[0][0] = dydt[0] - dydt[3];
		//		deltax[0][1] = dydt[0] - dydt[4];
		//		deltax[0][2] = dydt[0] - dydt[5];
		//
		//		deltax[1][0] = dydt[1] - dydt[6];
		//		deltax[1][1] = dydt[1] - dydt[7];
		//		deltax[1][2] = dydt[1] - dydt[8];
		//
		//		deltax[2][0] = dydt[2] - dydt[9];
		//		deltax[2][1] = dydt[2] - dydt[10];
		//		deltax[2][2] = dydt[2] - dydt[11];


		// ------------------------------------------------------------------------------------ //
		// TRYING A BETTER WAY ---------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		for( unsigned int idxRows = 0; idxRows < dim; idxRows++ )
		{
			for( unsigned int idxCols = 0; idxCols < dim; idxCols++ )
			{
				deltax[idxRows][idxCols] = dydt[idxRows] - dydt[dim*(idxRows+1)+idxCols];
			}
		}


		// ------------------------------------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj < dim; jj++ )
		//			{
		//				//printf( "[deltax[%d][%d] = %.6f]", ii, jj, deltax[ii][jj] );
		//				printf( "[%.12f]", deltax[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* GRAM-SCHIMIDT REORTHONORMALIZATION ===================================================================================== */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------ //
		// THE DUMMY WAY ---------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------ //

		double pdi1 = 0.0;
		double pdi2 = 0.0;

		double Norm1 = 0.0;
		double Norm2 = 0.0;
		double Norm3 = 0.0;


		// EXPONENT Lyap1
		vk[0][0] = deltax[0][0];
		vk[1][0] = deltax[1][0];
		vk[2][0] = deltax[2][0];

		Norm1 = sqrt( pow(vk[0][0],2)+pow(vk[1][0],2)+pow(vk[2][0],2) );

		uk[0][0] = vk[0][0]/Norm1;
		uk[1][0] = vk[1][0]/Norm1;
		uk[2][0] = vk[2][0]/Norm1;


		// EXPONENT Lyap2
		// 	- Remember: the numerator represents a dot product
		//	- Remember: the denumerator represents the square of each element of the vector
		pdi1 = ( uk[0][0]*deltax[0][1]+uk[1][0]*deltax[1][1]+uk[2][0]*deltax[2][1] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );

		vk[0][1] = deltax[0][1] - pdi1 * uk[0][0];
		vk[1][1] = deltax[1][1] - pdi1 * uk[1][0];
		vk[2][1] = deltax[2][1] - pdi1 * uk[2][0];

		Norm2 = sqrt( pow(vk[0][1],2)+pow(vk[1][1],2)+pow(vk[2][1],2) );

		uk[0][1] = vk[0][1]/Norm2;
		uk[1][1] = vk[1][1]/Norm2;
		uk[2][1] = vk[2][1]/Norm2;


		// EXPONENT Lyap3
		pdi1 = ( uk[0][0]*deltax[0][2]+uk[1][0]*deltax[1][2]+uk[2][0]*deltax[2][2] ) / ( uk[0][0]*uk[0][0]+uk[1][0]*uk[1][0]+uk[2][0]*uk[2][0] );
		pdi2 = ( uk[0][1]*deltax[0][2]+uk[1][1]*deltax[1][2]+uk[2][1]*deltax[2][2] ) / ( uk[0][1]*uk[0][1]+uk[1][1]*uk[1][1]+uk[2][1]*uk[2][1] );

		vk[0][2] = deltax[0][2] - pdi1*uk[0][0] - pdi2*uk[0][1];
		vk[1][2] = deltax[1][2] - pdi1*uk[1][0] - pdi2*uk[1][1];
		vk[2][2] = deltax[2][2] - pdi1*uk[2][0] - pdi2*uk[2][1];

		Norm3 = sqrt( pow(vk[0][2],2)+pow(vk[1][2],2)+pow(vk[2][2],2) );

		uk[0][2] = vk[0][2]/Norm3;
		uk[1][2] = vk[1][2]/Norm3;
		uk[2][2] = vk[2][2]/Norm3;


		//		// ------------------------------------------------------------------------------------ //
		//		// DEBUG - SCREEN - vk ---------------------------------------------------------------- //
		//		// ------------------------------------------------------------------------------------ //
		//
		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| vk[%d][%d] = %.12f |", ii, jj, vk[ii][jj] );
		//				printf( "[%.12f]", vk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );
		//
		//
		//		// ------------------------------------------------------------------------------------ //
		//		// SCREEN - uk ------------------------------------------------------------------------ //
		//		// ------------------------------------------------------------------------------------ //
		//
		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj=0; jj < dim; jj++ )
		//			{
		//				//printf( "| uk[%d][%d] = %.12f |", ii, jj, uk[ii][jj] );
		//				printf( "[%.12f]", uk[ii][jj] );
		//			}
		//
		//			//printf( "|\n" );
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* LYAPUNOV EXPONENTS CALCULATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// LYAPUNOV EXPONENTS SUMMATION ------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		LyapSoma[0] = LyapSoma[0] + log( Norm1 / delta );
		LyapSoma[1] = LyapSoma[1] + log( Norm2 / delta );
		LyapSoma[2] = LyapSoma[2] + log( Norm3 / delta );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//		printf( "\n" );
		//
		//		for( unsigned int ii = 0; ii < dim; ii++ )
		//		{
		//			for( unsigned int jj = 0; jj <= (idxIterations+1); jj++ )
		//			{
		//				//printf( "| LyapSoma[%d][%d] = %.8f | ", ii, jj, LyapSoma[ii][jj] );
		//				printf( "[%.12f]", LyapSoma[ii][jj] );
		//			}
		//			printf( "\n" );
		//		}
		//
		//		printf( "\n" );


		/* ======================================================================================================================== */
		/* PREPARE FOR THE NEXT ITERATION ========================================================================================= */
		/* ======================================================================================================================== */

		// ------------------------------------------------------------------------------------------------------------------------ //
		// INITIAL CONDITIONS - THE DUMMY WAY ------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		// ORIGINAL SYSTEM
		y_init[0] = dydt[0];
		y_init[1] = dydt[1];
		y_init[2] = dydt[2];

		// CLONES
		y_init[3] = dydt[0] + delta*uk[0][0];
		y_init[4] = dydt[0] + delta*uk[0][1];
		y_init[5] = dydt[0] + delta*uk[0][2];

		y_init[6] = dydt[1] + delta*uk[1][0];
		y_init[7] = dydt[1] + delta*uk[1][1];
		y_init[8] = dydt[1] + delta*uk[1][2];

		y_init[9]  = dydt[2] + delta*uk[2][0];
		y_init[10] = dydt[2] + delta*uk[2][1];
		y_init[11] = dydt[2] + delta*uk[2][2];

		// ------------------------------------------------------------------------------------------------------------------------ //

		idxIterations++;

		// ------------------------------------------------------------------------------------------------------------------------ //

		/* ======================================================================================================================== */

	} // END - ITERATIONS
	/* **************************************************************************************************************************** */


	/* **************************************************************************************************************************** */
	/* SYNC THREADS *************************************************************************************************************** */
	/* **************************************************************************************************************************** */

	__syncthreads();



	/* **************************************************************************************************************************** */
	// KERNEL OUTPUT: GLOBAL LYAPUNOV EXPONENTS *********************************************************************************** */
	/* **************************************************************************************************************************** */

	outLyap1[globalThreadIdx] = LyapSoma[0] / (double)(t_final - t_init);
	outLyap2[globalThreadIdx] = LyapSoma[1] / (double)(t_final - t_init);
	outLyap3[globalThreadIdx] = LyapSoma[2] / (double)(t_final - t_init);

	/* **************************************************************************************************************************** */


} // END - KERNEL
/* ******************************************************************************************************************************** */



/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
/* 															MAIN FUNCTION															*/
/* ******************************************************************************************************************************** */
/* ******************************************************************************************************************************** */
int main()
{

	/* **************************************************************************************************************************** */
	/* DEVICE INITIALIZATION ****************************************************************************************************** */
	/* **************************************************************************************************************************** */

	int numDevices = -1;	// number of devices
	int idxDevices = 0;

	cudaGetDeviceCount(&numDevices);

	if (numDevices == 0) {
		fprintf(stderr, "No CUDA devices found\n");
		return 1;
	}

	cudaError_t error = cudaSetDevice(idxDevices);

	if (error != cudaSuccess) {
		fprintf(stderr, "Error setting device to %d: %s\n", idxDevices, cudaGetErrorString(error));
		return 1;
	}


	//checkCudaErrors(cudaSetDevice(0));
	cudaSetDevice(0);

        // cudaDeviceReset causes the driver to clean up all state. While
        // not mandatory in normal operation, it is good practice.  It is also
        // needed to ensure correct operation when the application is being
        // profiled. Calling cudaDeviceReset causes all profile data to be
        // flushed before the application exits
        cudaDeviceReset();


	/* **************************************************************************************************************************** */
	/* SOME INITIALIZATIONS ******************************************************************************************************* */
	/* **************************************************************************************************************************** */

	unsigned int aux_counter_Control_Param = 0;


	/* **************************************************************************************************************************** */
	/* DYNAMICAL SYSTEM PARAMETERS ************************************************************************************************ */
	/* **************************************************************************************************************************** */

	double omega = 1.0;


	/* **************************************************************************************************************************** */
	/* CONTROL PARAMETERS ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// VARIATION STEP OF THE CONTROL PARAMETERS ----------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double nIncControlParameter1 = 0.1;
	double nIncControlParameter2 = 0.1;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CONTROL PARAMETER VECTOR CONSTRUCTION -------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //
	double vEpsilon_min = 0.0;
	double vEpsilon_max = 1.0;

	double vGamma_min = 0.2;
	double vGamma_max = 1.0;


	int vEpsilon_length = round( ((vEpsilon_max - vEpsilon_min)/nIncControlParameter1) + 1 );
	int vGamma_length   = round( ((vGamma_max   - vGamma_min)  /nIncControlParameter2) + 1 );


	double vEpsilon[vEpsilon_length];
	double vGamma[vGamma_length];



	for ( unsigned int ii = 0; ii < vEpsilon_length; ii++ )
	{
		if (ii == 0)
			vEpsilon[ii] = vEpsilon_min;

		else
			vEpsilon[ii] = vEpsilon[ii-1] + nIncControlParameter1;

		// ------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------- //
		// ------------------------------------------------------ //

		//printf("vEpsilon[%d] = %.4f\n", ii, vEpsilon[ii]);

		// ------------------------------------------------------ //

	}

	//printf( "\n" );



	for( unsigned int ii = 0; ii < vGamma_length; ii++ )
	{
		if ( ii == 0 )
			vGamma[ii] = vGamma_min;

		else
			vGamma[ii] = vGamma[ii-1] + nIncControlParameter2;

		// ------------------------------------------------------ //
		// DEBUG - SCREEN --------------------------------------- //
		// ------------------------------------------------------ //

		//printf("vGamma[%d] = %.4f\n", ii, vGamma[ii]);

		// ------------------------------------------------------ //

	}

	//printf("\n");


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// HOW MANY COMBINATONS ------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	const int nNumCombinations = (vEpsilon_length)*(vGamma_length);

	// ---------------------------------------------------------------------------------------------------------------------------- //

	printf("\n Control parameters combinations = %.d\n", nNumCombinations );

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* POINTERS USED TO SAVA DATA ON DISK ***************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// TEMPORAL CHARACTERISTICS AND SOME OTHER THINGS ----------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Header = fopen("data_CUDA_Duffing1989_SpaceParam_ClDyn_Header.dat", "w+");


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// LYAPUNOV EXPONENTS - Mz MATRIZ --------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	FILE *fileData_Mz_Lyap = fopen("data_CUDA_Duffing1989_SpaceParam_ClDyn_Mz_Lyap.dat", "w+");

	// ---------------------------------------------------------------------------------------------------------------------------- //

	if (fileData_Header == NULL)
	{
		printf(" Error opening the file 'data_CUDA_Duffing1989_SpaceParam_ClDyn_Header.dat' !\n");
		exit(1);
	}


	if (fileData_Mz_Lyap == NULL)
	{
		printf(" Error opening the file 'data_CUDA_Duffing1989_SpaceParam_ClDyn_Mz_Lyap.dat' !\n");
		exit(1);
	}

	// ---------------------------------------------------------------------------------------------------------------------------- //


	/* **************************************************************************************************************************** */
	/* PUT SOME STRINGS AT THE BEGINNING OF THE DATA FILES ************************************************************************ */
	/* **************************************************************************************************************************** */

	fprintf( fileData_Mz_Lyap, "#epsilon, gamma, omega, lambda1, lambda2, lambda3\n" );



	/* **************************************************************************************************************************** */
	/* VARIABLES FOR CUDA EVENTS ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// INITIALIZE VARIABLES FOR THE CUDA EVENTS ----------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	float elapsedTimeKernel, elapsedTimeGather;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// INITIALIZE CUDA EVENTS ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEvent_t startKernel, stopKernel;
	cudaEvent_t startGather, stopGather;


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CREATING EVENTS ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventCreate( &startKernel );
	cudaEventCreate( &stopKernel );

	cudaEventCreate( &startGather );
	cudaEventCreate( &stopGather );


	/* **************************************************************************************************************************** */
	/* POINTERS TO HOST MEMORY **************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double *Host_Lyap1, *Host_Lyap2, *Host_Lyap3;

	double *Host_Epsilon;
	double *Host_Gamma;
	double *Host_Omega;


	/* **************************************************************************************************************************** */
	/* POINTERS TO DEVICE MEMORY ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	double *Device_Lyap1, *Device_Lyap2, *Device_Lyap3;

	double *Device_Epsilon;
	double *Device_Gamma;
	double *Device_Omega;


	/* **************************************************************************************************************************** */
	/* ALLOCATE ARRAYS ON HOST **************************************************************************************************** */
	/* **************************************************************************************************************************** */

	Host_Lyap1 = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_Lyap2 = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_Lyap3 = (double *) malloc( (nNumCombinations)*sizeof(double) );

	Host_Epsilon = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_Gamma   = (double *) malloc( (nNumCombinations)*sizeof(double) );
	Host_Omega 	 = (double *) malloc( (nNumCombinations)*sizeof(double) );


	/* **************************************************************************************************************************** */
	/* ALLOCATE ARRAYS ON DEVICE ************************************************************************************************** */
	/* **************************************************************************************************************************** */

	cudaError_t errDevLyap1 = cudaMalloc( (void **) &Device_Lyap1, (nNumCombinations)*sizeof(double) );
	cudaError_t errDevLyap2 = cudaMalloc( (void **) &Device_Lyap2, (nNumCombinations)*sizeof(double) );
	cudaError_t errDevLyap3 = cudaMalloc( (void **) &Device_Lyap3, (nNumCombinations)*sizeof(double) );

	cudaError_t errDevEps = cudaMalloc( (void **) &Device_Epsilon, (nNumCombinations)*sizeof(double) );
	cudaError_t errDevGam = cudaMalloc( (void **) &Device_Gamma,   (nNumCombinations)*sizeof(double) );
	cudaError_t errDevOmg = cudaMalloc( (void **) &Device_Omega,   (nNumCombinations)*sizeof(double) );


	// IDENTIFY THE ERRORS
	if (errDevLyap1 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevLyap1), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevLyap2 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevLyap2), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevLyap3 != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevLyap3), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevEps != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevEps), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevGam != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevGam), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	if (errDevOmg != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errDevOmg), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	/* **************************************************************************************************************************** */
	/* INITIALIZE ARRAYS OF PARAMETERS ON HOST ************************************************************************************ */
	/* **************************************************************************************************************************** */

	for ( unsigned int idxEpsilon = 0; idxEpsilon < vEpsilon_length; idxEpsilon++ )
	{

		for ( unsigned int idxGamma = 0; idxGamma < vGamma_length; idxGamma++ )
		{

			// -------------------------------------------------------------------------------------------------------------------- //
			// CONTROL PARAMETERS ------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			Host_Epsilon[aux_counter_Control_Param] = vEpsilon[idxEpsilon];
			Host_Gamma[aux_counter_Control_Param]   = vGamma[idxGamma];


			// -------------------------------------------------------------------------------------------------------------------- //
			// OTHER PARAMETERS --------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			Host_Omega[aux_counter_Control_Param] = omega;


			// -------------------------------------------------------------------------------------------------------------------- //
			// AUX UPDATE --------------------------------------------------------------------------------------------------------- //
			// -------------------------------------------------------------------------------------------------------------------- //

			aux_counter_Control_Param++;

		}

	}


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// SCREEN - DEBUG ------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	//	printf( "\n" );
	//
	//	for ( unsigned int ii = 0; ii < nNumCombinations; ii++ )
	//		printf( " Host_Epsilon[%d] = %.4f  Host_Gamma[%d] = %.4f \n", ii, Host_Epsilon[ii], ii, Host_Gamma[ii] );



	/* **************************************************************************************************************************** */
	/* COPY DATA FROM HOST TO DEVICE MEMORY *************************************************************************************** */
	/* **************************************************************************************************************************** */

	cudaMemcpy( Device_Epsilon, Host_Epsilon, (nNumCombinations)*sizeof(double), cudaMemcpyHostToDevice );
	cudaMemcpy( Device_Gamma,   Host_Gamma,   (nNumCombinations)*sizeof(double), cudaMemcpyHostToDevice );
	cudaMemcpy( Device_Omega,   Host_Omega,   (nNumCombinations)*sizeof(double), cudaMemcpyHostToDevice );



	/* **************************************************************************************************************************** */
	/* COMPUTE THE EXECUTION CONFIGURATION **************************************************************************************** */
	/* **************************************************************************************************************************** */

	//	dim3 dimBlock( BlockSize, 1, 1 );
	//	dim3 dimGrid ( (N/dimBlock.x) + (!(N%dimBlock.x)?0:1) );

	//dim3 dimBlock ( BlockSize, 1, 1 );
	//dim3 dimGrid  ( ceil( nNumCombinations/(double)BlockSize ), 1 );
	dim3 dimBlock ( 16, 16, 1 );
	dim3 dimGrid  ( ceil( nNumCombinations/(double)16.0 ), ceil( nNumCombinations/(double)16.0 ) );



	/* **************************************************************************************************************************** */
	/* EXECUTE THE KERNEL ********************************************************************************************************* */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// START RECORDING ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord( startKernel, 0 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// EXECUTE THE MAIN KERNEL ---------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	kernel_Duffing1989_SpaceParam_ClDyn_Epsilon_Gamma<<<dimGrid,dimBlock>>>(
			Device_Lyap1, Device_Lyap2, Device_Lyap3,
			Device_Epsilon,
			Device_Gamma,
			Device_Omega,
			nNumCombinations);


    	// ---------------------------------------------------------------------------------------------------------------------------- //
	// SYNCHRONIZE THREADS -------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	//cudaThreadSynchronize();

	//cudaDeviceSynchronize();

    cudaError_t errorss = cudaGetLastError();
    if(errorss!=cudaSuccess)
    {
       fprintf(stderr,"ERROR: %s\n", cudaGetErrorString(errorss) );
       exit(-1);
    }


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// FINISH RECORDING ----------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord( stopKernel, 0 );
	cudaEventSynchronize( stopKernel );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CALCULATE ELAPSED TIME ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaError_t errTimeKernel = cudaEventElapsedTime(&elapsedTimeKernel, startKernel, stopKernel);


	printf( "\n Time for the complete kernel execution [ms]: %.6f", elapsedTimeKernel );

	printf( "\n Time for the complete kernel execution [s] : %.6f \n\n", (elapsedTimeKernel / 1000.0) );


	if (errTimeKernel != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errTimeKernel), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}


	/* **************************************************************************************************************************** */
	/* COPY DATA FROM DEVICE MEMORY TO HOST MEMORY ******************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// START RECORDING ------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord(startGather, 0);


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// COPY DATA ------------------------------------------------------------------------------------------------------------------ //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaMemcpy( Host_Lyap1, Device_Lyap1, (nNumCombinations)*sizeof(double), cudaMemcpyDeviceToHost );
	cudaMemcpy( Host_Lyap2, Device_Lyap2, (nNumCombinations)*sizeof(double), cudaMemcpyDeviceToHost );
	cudaMemcpy( Host_Lyap3, Device_Lyap3, (nNumCombinations)*sizeof(double), cudaMemcpyDeviceToHost );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// FINISH RECORDING ----------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaEventRecord(stopGather, 0);
	cudaEventSynchronize(stopGather);


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CALCULATE ELAPSED TIME ----------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaError_t errTimeGather = cudaEventElapsedTime(&elapsedTimeGather, startGather, stopGather);

	printf( " Time for copy data from device memory to host memory [ms]: %.6f \n", elapsedTimeGather);

	printf( " Time for copy data from device memory to host memory [s]:  %.6f \n", (elapsedTimeGather / 1000.0) );

	if (errTimeGather != cudaSuccess) {
		printf("%s in %s at line %d\n", cudaGetErrorString( errTimeKernel), __FILE__, __LINE__);
		exit(EXIT_FAILURE);
	}



	/* **************************************************************************************************************************** */
	/* PRINT/SAVE DATA ************************************************************************************************************ */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// LYAPUNOV EXPONENTS --------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	printf( "\n" );

	for ( unsigned int idx_storeLyap = 0; idx_storeLyap < nNumCombinations; idx_storeLyap++ )
	{

		// ------------------------------------------------------------------------------------------------------------------------ //
		// SCREEN ----------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		//printf( " Host_Epsilon[%d] = %.4f  Host_Gamma[%d] = %.4f  ", idx_storeLyap, Host_Epsilon[idx_storeLyap], idx_storeLyap, Host_Gamma[idx_storeLyap] );

		//printf( " H_Lyap1[%d] = %.6f  ", idx_storeLyap, Host_Lyap1[idx_storeLyap] );

		//printf( " H_Lyap2[%d] = %.6f  ", idx_storeLyap, Host_Lyap2[idx_storeLyap] );

		//printf( " H_Lyap3[%d] = %.6f\n", idx_storeLyap, Host_Lyap3[idx_storeLyap] );


		// ------------------------------------------------------------------------------------------------------------------------ //
		// DISK ------------------------------------------------------------------------------------------------------------------- //
		// ------------------------------------------------------------------------------------------------------------------------ //

		fprintf( fileData_Mz_Lyap, "%.4f"  , Host_Epsilon[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.4f", Host_Gamma[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.4f", Host_Omega[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.12f", Host_Lyap1[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.12f", Host_Lyap2[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, ", %.12f", Host_Lyap3[idx_storeLyap] );

		fprintf( fileData_Mz_Lyap, "\n" );

	}

	printf( "\n" );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLOSE FILES ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	fclose(fileData_Mz_Lyap);



	/* **************************************************************************************************************************** */
	/* DISK - TOTAL COMPUTATIONAL TIME AND SOME OTHERS PARAMETERS ***************************************************************** */
	/* **************************************************************************************************************************** */

	fprintf( fileData_Header, "Control parameters: epsilon, gamma\n" );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "nIncControlParameter1 = %.4f\n", nIncControlParameter1 );
	fprintf( fileData_Header, "nIncControlParameter2 = %.4f\n", nIncControlParameter2 );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vEpsilon_min = %.4f\n", vEpsilon_min );
	fprintf( fileData_Header, "vEpsilon_max = %.4f\n", vEpsilon_max );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vGamma_min = %.4f\n", vGamma_min );
	fprintf( fileData_Header, "vGamma_max = %.4f\n", vGamma_max );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "vEpsilon_length = %d\n", vEpsilon_length );
	fprintf( fileData_Header, "vGamma_length = %d\n", vGamma_length );
	fprintf( fileData_Header, "\n");


	fprintf( fileData_Header, "t_final = %.4f\n", t_final );
	fprintf( fileData_Header, "\n");

	fprintf( fileData_Header, "[block_size = %d] Time for the kernel [s]: %.12f \n", BlockSize, (elapsedTimeKernel / 1000.0) );
	fprintf( fileData_Header, "[block_size = %d] Time for the kernel [h]: %.12f \n\n", BlockSize, (elapsedTimeKernel / 1000.0) / 3600.0 );

	fprintf( fileData_Header, "[block_size = %d] Time for copy data from device memory to host memory [s]: %.12f \n", BlockSize, (elapsedTimeGather / 1000.0) );
	fprintf( fileData_Header, "[block_size = %d] Time for copy data from device memory to host memory [h]: %.12f \n\n", BlockSize, (elapsedTimeGather / 1000.0) / 3600.0 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// CLOSE FILES ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	fclose(fileData_Header);



	/* **************************************************************************************************************************** */
	/* IMPORTANT: FREE MEMORY ***************************************************************************************************** */
	/* **************************************************************************************************************************** */

	// ---------------------------------------------------------------------------------------------------------------------------- //
	// HOST MEMORY ---------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	free( Host_Lyap1 );
	free( Host_Lyap2 );
	free( Host_Lyap3 );


	// ---------------------------------------------------------------------------------------------------------------------------- //
	// DEVICE MEMORY -------------------------------------------------------------------------------------------------------------- //
	// ---------------------------------------------------------------------------------------------------------------------------- //

	cudaFree( Device_Lyap1 );
	cudaFree( Device_Lyap2 );
	cudaFree( Device_Lyap3 );

	cudaFree( Device_Epsilon );
	cudaFree( Device_Gamma );
	cudaFree( Device_Omega );



	/* **************************************************************************************************************************** */

	printf("\n That's all!!!\n\n");

	return 0;

	/* **************************************************************************************************************************** */

}
